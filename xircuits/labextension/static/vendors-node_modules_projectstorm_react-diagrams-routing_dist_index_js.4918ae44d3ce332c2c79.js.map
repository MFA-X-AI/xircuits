{"version":3,"file":"vendors-node_modules_projectstorm_react-diagrams-routing_dist_index_js.4918ae44d3ce332c2c79.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,8BAA8B,mBAAO,CAAC,yGAAmC;AACzE,cAAc,mBAAO,CAAC,0DAAO;AAC7B,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,mBAAmB,mBAAO,CAAC,mFAAwB;AACnD;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,wCAAwC;AAC9E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D,uEAAuE,gFAAgF;AACvJ;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;ACxDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,WAAW,mBAAO,CAAC,4EAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;ACzFa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,8HAA+B;AACpD,aAAa,mBAAO,CAAC,0HAA6B;AAClD,aAAa,mBAAO,CAAC,4HAA8B;AACnD,aAAa,mBAAO,CAAC,0HAA6B;AAClD,aAAa,mBAAO,CAAC,4HAA8B;AACnD,aAAa,mBAAO,CAAC,wHAA4B;AACjD,aAAa,mBAAO,CAAC,4GAAsB;AAC3C,aAAa,mBAAO,CAAC,0GAAqB;AAC1C;;;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B,cAAc,mBAAO,CAAC,oDAAO;AAC7B,+BAA+B,mBAAO,CAAC,qHAAwB;AAC/D,gCAAgC,mBAAO,CAAC,uHAAyB;AACjE,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,aAAa,mBAAO,CAAC,sDAAe;AACpC,kCAAkC,mBAAO,CAAC,0JAAuC;AACjF,4BAA4B,mBAAO,CAAC,6IAAiC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,8DAA8D;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iFAAiF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;;;;;;;;;AChOa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,iCAAiC,mBAAO,CAAC,yHAA0B;AACnE,kCAAkC,mBAAO,CAAC,0JAAuC;AACjF;AACA,4BAA4B;AAC5B,8BAA8B,4DAA4D;AAC1F;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,cAAc,mBAAO,CAAC,oDAAO;AAC7B,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,sBAAsB,mBAAO,CAAC,6GAAuB;AACrD,kCAAkC,mBAAO,CAAC,0JAAuC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,aAAa,GAAG;AAC1G,gCAAgC,oBAAoB;AACpD,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,cAAc,mBAAO,CAAC,oDAAO;AAC7B,+BAA+B,mBAAO,CAAC,qHAAwB;AAC/D,kCAAkC,mBAAO,CAAC,0JAAuC;AACjF,8BAA8B,mBAAO,CAAC,mHAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,8DAA8D;AAChJ;AACA;AACA,6BAA6B;AAC7B;AACA;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,kCAAkC,mBAAO,CAAC,0JAAuC;AACjF,gCAAgC,mBAAO,CAAC,uHAAyB;AACjE;AACA,4BAA4B;AAC5B,8BAA8B,0DAA0D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA,2BAA2B;AAC3B;;;;;;;;;;ACxDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,cAAc,mBAAO,CAAC,oDAAO;AAC7B,8BAA8B,mBAAO,CAAC,yGAAmC;AACzE,kCAAkC,mBAAO,CAAC,0JAAuC;AACjF,mBAAmB,mBAAO,CAAC,mFAAwB;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,aAAa,GAAG;AAC1G,gCAAgC,oBAAoB;AACpD,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA,0CAA0C,iEAAiE;AAC3G;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/Na;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;;AAEF,oCAAoC,iCAAiC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,uCAAuC,cAAc,WAAW,YAAY,UAAU,MAAM,2CAA2C,UAAU,sBAAsB,eAAe,2BAA2B,0BAA0B,cAAc,2CAA2C,gCAAgC,OAAO,mFAAmF;;AAEtpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,KAAK;AACvB;AACA;;;;;;;;;;ACpIa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;;AAEF,oCAAoC,iCAAiC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,uCAAuC,cAAc,WAAW,YAAY,UAAU,MAAM,2CAA2C,UAAU,sBAAsB,eAAe,2BAA2B,0BAA0B,cAAc,2CAA2C,gCAAgC,OAAO,mFAAmF;;AAEtpB,YAAY,mBAAO,CAAC,+CAAQ;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA,0DAA0D,wBAAwB;AAClF;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qBAAqB,qBAAqB;AAC1C;AACA,0DAA0D,wBAAwB;AAClF;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qBAAqB,kBAAkB,IAAI,kBAAkB,IAAI,kBAAkB;AACnF;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;;AAET;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;;AAEX;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;;AAET;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;;AAET;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sEAAsE,gEAAgE;AACtI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA","sources":["webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/dagre/DagreEngine.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/engine/PathFinding.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/index.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/link/PathFindingLinkFactory.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/link/PathFindingLinkModel.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/link/PathFindingLinkWidget.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/link/RightAngleLinkFactory.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/link/RightAngleLinkModel.js","webpack://xircuits/./node_modules/@projectstorm/react-diagrams-routing/dist/link/RightAngleLinkWidget.js","webpack://xircuits/./node_modules/paths-js/geom.js","webpack://xircuits/./node_modules/paths-js/path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DagreEngine = void 0;\nconst react_diagrams_core_1 = require(\"@projectstorm/react-diagrams-core\");\nconst dagre = require(\"dagre\");\nconst _ = require(\"lodash\");\nconst geometry_1 = require(\"@projectstorm/geometry\");\nclass DagreEngine {\n    constructor(options = {}) {\n        this.options = options;\n    }\n    redistribute(model) {\n        // Create a new directed graph\n        var g = new dagre.graphlib.Graph({\n            multigraph: true,\n            compound: true\n        });\n        g.setGraph(this.options.graph || {});\n        g.setDefaultEdgeLabel(function () {\n            return {};\n        });\n        // set nodes\n        _.forEach(model.getNodes(), (node) => {\n            g.setNode(node.getID(), { width: node.width, height: node.height });\n        });\n        _.forEach(model.getLinks(), (link) => {\n            // set edges\n            if (link.getSourcePort() && link.getTargetPort()) {\n                g.setEdge({\n                    v: link.getSourcePort().getNode().getID(),\n                    w: link.getTargetPort().getNode().getID(),\n                    name: link.getID()\n                });\n            }\n        });\n        // layout the graph\n        dagre.layout(g);\n        g.nodes().forEach((v) => {\n            const node = g.node(v);\n            model.getNode(v).setPosition(node.x - node.width / 2, node.y - node.height / 2);\n        });\n        // also include links?\n        if (this.options.includeLinks) {\n            g.edges().forEach((e) => {\n                const edge = g.edge(e);\n                const link = model.getLink(e.name);\n                const points = [link.getFirstPoint()];\n                for (let i = 1; i < edge.points.length - 1; i++) {\n                    points.push(new react_diagrams_core_1.PointModel({ link: link, position: new geometry_1.Point(edge.points[i].x, edge.points[i].y) }));\n                }\n                link.setPoints(points.concat(link.getLastPoint()));\n            });\n        }\n    }\n}\nexports.DagreEngine = DagreEngine;\n//# sourceMappingURL=DagreEngine.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathFinding = void 0;\nconst PF = require(\"pathfinding\");\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\nconst pathFinderInstance = new PF.JumpPointFinder({\n    heuristic: PF.Heuristic.manhattan,\n    diagonalMovement: PF.DiagonalMovement.Never\n});\nclass PathFinding {\n    constructor(factory) {\n        this.instance = pathFinderInstance;\n        this.factory = factory;\n    }\n    /**\n     * Taking as argument a fully unblocked walking matrix, this method\n     * finds a direct path from point A to B.\n     */\n    calculateDirectPath(from, to) {\n        const matrix = this.factory.getCanvasMatrix();\n        const grid = new PF.Grid(matrix);\n        return pathFinderInstance.findPath(this.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)), grid);\n    }\n    /**\n     * Using @link{#calculateDirectPath}'s result as input, we here\n     * determine the first walkable point found in the matrix that includes\n     * blocked paths.\n     */\n    calculateLinkStartEndCoords(matrix, path) {\n        const startIndex = path.findIndex((point) => {\n            if (matrix[point[1]])\n                return matrix[point[1]][point[0]] === 0;\n            else\n                return false;\n        });\n        const endIndex = path.length -\n            1 -\n            path\n                .slice()\n                .reverse()\n                .findIndex((point) => {\n                if (matrix[point[1]])\n                    return matrix[point[1]][point[0]] === 0;\n                else\n                    return false;\n            });\n        // are we trying to create a path exclusively through blocked areas?\n        // if so, let's fallback to the linear routing\n        if (startIndex === -1 || endIndex === -1) {\n            return undefined;\n        }\n        const pathToStart = path.slice(0, startIndex);\n        const pathToEnd = path.slice(endIndex);\n        return {\n            start: {\n                x: path[startIndex][0],\n                y: path[startIndex][1]\n            },\n            end: {\n                x: path[endIndex][0],\n                y: path[endIndex][1]\n            },\n            pathToStart,\n            pathToEnd\n        };\n    }\n    /**\n     * Puts everything together: merges the paths from/to the centre of the ports,\n     * with the path calculated around other elements.\n     */\n    calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd) {\n        // generate the path based on the matrix with obstacles\n        const grid = new PF.Grid(routingMatrix);\n        const dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n        // aggregate everything to have the calculated path ready for rendering\n        const pathCoords = pathToStart\n            .concat(dynamicPath, pathToEnd)\n            .map((coords) => [\n            this.factory.translateRoutingX(coords[0], true),\n            this.factory.translateRoutingY(coords[1], true)\n        ]);\n        return PF.Util.compressPath(pathCoords);\n    }\n}\nexports.PathFinding = PathFinding;\n//# sourceMappingURL=PathFinding.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./link/PathFindingLinkFactory\"), exports);\n__exportStar(require(\"./link/PathFindingLinkModel\"), exports);\n__exportStar(require(\"./link/PathFindingLinkWidget\"), exports);\n__exportStar(require(\"./link/RightAngleLinkWidget\"), exports);\n__exportStar(require(\"./link/RightAngleLinkFactory\"), exports);\n__exportStar(require(\"./link/RightAngleLinkModel\"), exports);\n__exportStar(require(\"./engine/PathFinding\"), exports);\n__exportStar(require(\"./dagre/DagreEngine\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathFindingLinkFactory = void 0;\nconst React = require(\"react\");\nconst PathFindingLinkModel_1 = require(\"./PathFindingLinkModel\");\nconst PathFindingLinkWidget_1 = require(\"./PathFindingLinkWidget\");\nconst _ = require(\"lodash\");\nconst Path = require(\"paths-js/path\");\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\nclass PathFindingLinkFactory extends react_diagrams_defaults_1.DefaultLinkFactory {\n    constructor() {\n        super(PathFindingLinkFactory.NAME);\n        this.ROUTING_SCALING_FACTOR = 5;\n        // calculated only when smart routing is active\n        this.canvasMatrix = [];\n        this.routingMatrix = [];\n        // used when at least one element has negative coordinates\n        this.hAdjustmentFactor = 0;\n        this.vAdjustmentFactor = 0;\n        /**\n         * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n         * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n         */\n        this.calculateMatrixDimensions = () => {\n            const allNodesCoords = _.values(this.engine.getModel().getNodes()).map((item) => ({\n                x: item.getX(),\n                width: item.width,\n                y: item.getY(),\n                height: item.height\n            }));\n            const allLinks = _.values(this.engine.getModel().getLinks());\n            const allPortsCoords = _.flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\n                .filter((port) => port !== null)\n                .map((item) => ({\n                x: item.getX(),\n                width: item.width,\n                y: item.getY(),\n                height: item.height\n            }));\n            const allPointsCoords = _.flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\n                // points don't have width/height, so let's just use 0\n                x: item.getX(),\n                width: 0,\n                y: item.getY(),\n                height: 0\n            }));\n            const sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n            const canvas = this.engine.getCanvas();\n            const concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n            const minX = Math.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n                this.ROUTING_SCALING_FACTOR;\n            const maxXElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\n            const maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n            const minYCoords = _.minBy(concatedCoords, 'y');\n            const minY = Math.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n            const maxYElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\n            const maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n            return {\n                width: Math.ceil(Math.abs(minX) + maxX),\n                hAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n                height: Math.ceil(Math.abs(minY) + maxY),\n                vAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n            };\n        };\n        /**\n         * Updates (by reference) where nodes will be drawn on the matrix passed in.\n         */\n        this.markNodes = (matrix) => {\n            _.values(this.engine.getModel().getNodes()).forEach((node) => {\n                const startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n                const endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n                const startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n                const endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n                for (let x = startX - 1; x <= endX + 1; x++) {\n                    for (let y = startY - 1; y < endY + 1; y++) {\n                        this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n                    }\n                }\n            });\n        };\n        /**\n         * Updates (by reference) where ports will be drawn on the matrix passed in.\n         */\n        this.markPorts = (matrix) => {\n            const allElements = _.flatMap(_.values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort())));\n            allElements\n                .filter((port) => port !== null)\n                .forEach((port) => {\n                const startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n                const endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n                const startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n                const endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n                for (let x = startX - 1; x <= endX + 1; x++) {\n                    for (let y = startY - 1; y < endY + 1; y++) {\n                        this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n                    }\n                }\n            });\n        };\n        this.markMatrixPoint = (matrix, x, y) => {\n            if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n                matrix[y][x] = 1;\n            }\n        };\n    }\n    setDiagramEngine(engine) {\n        super.setDiagramEngine(engine);\n        // listen for drag changes\n        engine.getStateMachine().registerListener({\n            stateChanged: (event) => {\n                if (event.newState instanceof react_canvas_core_1.AbstractDisplacementState) {\n                    const deRegister = engine.getActionEventBus().registerAction(new react_canvas_core_1.Action({\n                        type: react_canvas_core_1.InputType.MOUSE_UP,\n                        fire: () => {\n                            this.calculateRoutingMatrix();\n                            engine.repaintCanvas();\n                            deRegister();\n                        }\n                    }));\n                }\n            }\n        });\n        this.listener = engine.registerListener({\n            canvasReady: () => {\n                _.defer(() => {\n                    this.calculateRoutingMatrix();\n                    engine.repaintCanvas();\n                });\n            }\n        });\n    }\n    setFactoryBank(bank) {\n        super.setFactoryBank(bank);\n        if (!bank && this.listener) {\n            this.listener.deregister();\n        }\n    }\n    generateReactWidget(event) {\n        return React.createElement(PathFindingLinkWidget_1.PathFindingLinkWidget, { diagramEngine: this.engine, link: event.model, factory: this });\n    }\n    generateModel(event) {\n        return new PathFindingLinkModel_1.PathFindingLinkModel();\n    }\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all walkable points are marked by zeros.\n     * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n     */\n    getCanvasMatrix() {\n        if (this.canvasMatrix.length === 0) {\n            this.calculateCanvasMatrix();\n        }\n        return this.canvasMatrix;\n    }\n    calculateCanvasMatrix() {\n        const { width: canvasWidth, hAdjustmentFactor, height: canvasHeight, vAdjustmentFactor } = this.calculateMatrixDimensions();\n        this.hAdjustmentFactor = hAdjustmentFactor;\n        this.vAdjustmentFactor = vAdjustmentFactor;\n        const matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n        const matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n        this.canvasMatrix = _.range(0, matrixHeight).map(() => {\n            return new Array(matrixWidth).fill(0);\n        });\n    }\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 1 1 0 0 0 0 |\n     * | 0 0 1 1 0 0 1 1 |\n     * | 0 0 0 0 0 0 1 1 |\n     * | 1 1 0 0 0 0 0 0 |\n     * | 1 1 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all points blocked by a node (and its ports) are\n     * marked as 1; points were there is nothing (ie, free) receive 0.\n     */\n    getRoutingMatrix() {\n        if (this.routingMatrix.length === 0) {\n            this.calculateRoutingMatrix();\n        }\n        return this.routingMatrix;\n    }\n    calculateRoutingMatrix() {\n        const matrix = _.cloneDeep(this.getCanvasMatrix());\n        // nodes need to be marked as blocked points\n        this.markNodes(matrix);\n        // same thing for ports\n        this.markPorts(matrix);\n        this.routingMatrix = matrix;\n    }\n    /**\n     * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n     * We use the functions below to translate back and forth between these coordinates, relying on the\n     * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n     */\n    translateRoutingX(x, reverse = false) {\n        return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n    }\n    translateRoutingY(y, reverse = false) {\n        return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n    }\n    generateDynamicPath(pathCoords) {\n        let path = Path();\n        path = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n        pathCoords.slice(1).forEach((coords) => {\n            path = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n        });\n        return path.print();\n    }\n}\nexports.PathFindingLinkFactory = PathFindingLinkFactory;\nPathFindingLinkFactory.NAME = 'pathfinding';\n//# sourceMappingURL=PathFindingLinkFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathFindingLinkModel = void 0;\nconst PathFindingLinkFactory_1 = require(\"./PathFindingLinkFactory\");\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nclass PathFindingLinkModel extends react_diagrams_defaults_1.DefaultLinkModel {\n    constructor(options = {}) {\n        super(Object.assign({ type: PathFindingLinkFactory_1.PathFindingLinkFactory.NAME }, options));\n    }\n    performanceTune() {\n        return false;\n    }\n}\nexports.PathFindingLinkModel = PathFindingLinkModel;\n//# sourceMappingURL=PathFindingLinkModel.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathFindingLinkWidget = void 0;\nconst React = require(\"react\");\nconst _ = require(\"lodash\");\nconst PathFinding_1 = require(\"../engine/PathFinding\");\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nclass PathFindingLinkWidget extends React.Component {\n    constructor(props) {\n        super(props);\n        this.refPaths = [];\n        this.state = {\n            selected: false\n        };\n        this.pathFinding = new PathFinding_1.PathFinding(this.props.factory);\n    }\n    componentDidUpdate() {\n        this.props.link.setRenderedPaths(this.refPaths.map((ref) => {\n            return ref.current;\n        }));\n    }\n    componentDidMount() {\n        this.props.link.setRenderedPaths(this.refPaths.map((ref) => {\n            return ref.current;\n        }));\n    }\n    componentWillUnmount() {\n        this.props.link.setRenderedPaths([]);\n    }\n    generateLink(path, id) {\n        const ref = React.createRef();\n        this.refPaths.push(ref);\n        return (React.createElement(react_diagrams_defaults_1.DefaultLinkSegmentWidget, { key: `link-${id}`, path: path, selected: this.state.selected, diagramEngine: this.props.diagramEngine, factory: this.props.diagramEngine.getFactoryForLink(this.props.link), link: this.props.link, forwardRef: ref, onSelection: (selected) => {\n                this.setState({ selected: selected });\n            }, extras: {} }));\n    }\n    render() {\n        this.refPaths = [];\n        //ensure id is present for all points on the path\n        var points = this.props.link.getPoints();\n        var paths = [];\n        // first step: calculate a direct path between the points being linked\n        const directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n        const routingMatrix = this.props.factory.getRoutingMatrix();\n        // now we need to extract, from the routing matrix, the very first walkable points\n        // so they can be used as origin and destination of the link to be created\n        const smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n        if (smartLink) {\n            const { start, end, pathToStart, pathToEnd } = smartLink;\n            // second step: calculate a path avoiding hitting other elements\n            const simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n            paths.push(\n            //smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n            this.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0'));\n        }\n        return React.createElement(React.Fragment, null, paths);\n    }\n}\nexports.PathFindingLinkWidget = PathFindingLinkWidget;\n//# sourceMappingURL=PathFindingLinkWidget.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RightAngleLinkFactory = void 0;\nconst React = require(\"react\");\nconst RightAngleLinkWidget_1 = require(\"./RightAngleLinkWidget\");\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nconst RightAngleLinkModel_1 = require(\"./RightAngleLinkModel\");\n/**\n * @author Daniel Lazar\n */\nclass RightAngleLinkFactory extends react_diagrams_defaults_1.DefaultLinkFactory {\n    constructor() {\n        super(RightAngleLinkFactory.NAME);\n    }\n    generateModel(event) {\n        return new RightAngleLinkModel_1.RightAngleLinkModel();\n    }\n    generateReactWidget(event) {\n        return React.createElement(RightAngleLinkWidget_1.RightAngleLinkWidget, { diagramEngine: this.engine, link: event.model, factory: this });\n    }\n}\nexports.RightAngleLinkFactory = RightAngleLinkFactory;\nRightAngleLinkFactory.NAME = 'rightAngle';\n//# sourceMappingURL=RightAngleLinkFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RightAngleLinkModel = void 0;\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nconst RightAngleLinkFactory_1 = require(\"./RightAngleLinkFactory\");\nclass RightAngleLinkModel extends react_diagrams_defaults_1.DefaultLinkModel {\n    constructor(options = {}) {\n        super(Object.assign({ type: RightAngleLinkFactory_1.RightAngleLinkFactory.NAME }, options));\n        this.lastHoverIndexOfPath = 0;\n        this._lastPathXdirection = false;\n        this._firstPathXdirection = false;\n    }\n    setFirstAndLastPathsDirection() {\n        let points = this.getPoints();\n        for (let i = 1; i < points.length; i += points.length - 2) {\n            let dx = Math.abs(points[i].getX() - points[i - 1].getX());\n            let dy = Math.abs(points[i].getY() - points[i - 1].getY());\n            if (i - 1 === 0) {\n                this._firstPathXdirection = dx > dy;\n            }\n            else {\n                this._lastPathXdirection = dx > dy;\n            }\n        }\n    }\n    // @ts-ignore\n    addPoint(pointModel, index = 1) {\n        // @ts-ignore\n        super.addPoint(pointModel, index);\n        this.setFirstAndLastPathsDirection();\n        return pointModel;\n    }\n    deserialize(event) {\n        super.deserialize(event);\n        this.setFirstAndLastPathsDirection();\n    }\n    setManuallyFirstAndLastPathsDirection(first, last) {\n        this._firstPathXdirection = first;\n        this._lastPathXdirection = last;\n    }\n    getLastPathXdirection() {\n        return this._lastPathXdirection;\n    }\n    getFirstPathXdirection() {\n        return this._firstPathXdirection;\n    }\n    setWidth(width) {\n        this.options.width = width;\n        this.fireEvent({ width }, 'widthChanged');\n    }\n    setColor(color) {\n        this.options.color = color;\n        this.fireEvent({ color }, 'colorChanged');\n    }\n}\nexports.RightAngleLinkModel = RightAngleLinkModel;\n//# sourceMappingURL=RightAngleLinkModel.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RightAngleLinkWidget = void 0;\nconst React = require(\"react\");\nconst react_diagrams_core_1 = require(\"@projectstorm/react-diagrams-core\");\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nconst geometry_1 = require(\"@projectstorm/geometry\");\nclass RightAngleLinkWidget extends React.Component {\n    constructor(props) {\n        super(props);\n        this.handleMove = function (event) {\n            this.draggingEvent(event, this.dragging_index);\n        }.bind(this);\n        this.handleUp = function (event) {\n            // Unregister handlers to avoid multiple event handlers for other links\n            this.setState({ canDrag: false, selected: false });\n            window.removeEventListener('mousemove', this.handleMove);\n            window.removeEventListener('mouseup', this.handleUp);\n        }.bind(this);\n        this.refPaths = [];\n        this.state = {\n            selected: false,\n            canDrag: false\n        };\n        this.dragging_index = 0;\n    }\n    componentDidUpdate() {\n        this.props.link.setRenderedPaths(this.refPaths.map((ref) => {\n            return ref.current;\n        }));\n    }\n    componentDidMount() {\n        this.props.link.setRenderedPaths(this.refPaths.map((ref) => {\n            return ref.current;\n        }));\n    }\n    componentWillUnmount() {\n        this.props.link.setRenderedPaths([]);\n    }\n    generateLink(path, extraProps, id) {\n        const ref = React.createRef();\n        this.refPaths.push(ref);\n        return (React.createElement(react_diagrams_defaults_1.DefaultLinkSegmentWidget, { key: `link-${id}`, path: path, selected: this.state.selected, diagramEngine: this.props.diagramEngine, factory: this.props.diagramEngine.getFactoryForLink(this.props.link), link: this.props.link, forwardRef: ref, onSelection: (selected) => {\n                this.setState({ selected: selected });\n            }, extras: extraProps }));\n    }\n    calculatePositions(points, event, index, coordinate) {\n        // If path is first or last add another point to keep node port on its position\n        if (index === 0) {\n            let point = new react_diagrams_core_1.PointModel({\n                link: this.props.link,\n                position: new geometry_1.Point(points[index].getX(), points[index].getY())\n            });\n            this.props.link.addPoint(point, index);\n            this.dragging_index++;\n            return;\n        }\n        else if (index === points.length - 2) {\n            let point = new react_diagrams_core_1.PointModel({\n                link: this.props.link,\n                position: new geometry_1.Point(points[index + 1].getX(), points[index + 1].getY())\n            });\n            this.props.link.addPoint(point, index + 1);\n            return;\n        }\n        // Merge two points if it is not close to node port and close to each other\n        if (index - 2 > 0) {\n            let _points = {\n                [index - 2]: points[index - 2].getPosition(),\n                [index + 1]: points[index + 1].getPosition(),\n                [index - 1]: points[index - 1].getPosition()\n            };\n            if (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n                _points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n                _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n                points[index - 2].setPosition(_points[index - 2]);\n                points[index + 1].setPosition(_points[index + 1]);\n                points[index - 1].remove();\n                points[index - 1].remove();\n                this.dragging_index--;\n                this.dragging_index--;\n                return;\n            }\n        }\n        // Merge two points if it is not close to node port\n        if (index + 2 < points.length - 2) {\n            let _points = {\n                [index + 3]: points[index + 3].getPosition(),\n                [index + 2]: points[index + 2].getPosition(),\n                [index + 1]: points[index + 1].getPosition(),\n                [index]: points[index].getPosition()\n            };\n            if (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n                _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n                _points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n                points[index].setPosition(_points[index]);\n                points[index + 3].setPosition(_points[index + 3]);\n                points[index + 1].remove();\n                points[index + 1].remove();\n                return;\n            }\n        }\n        // If no condition above handled then just update path points position\n        let _points = {\n            [index]: points[index].getPosition(),\n            [index + 1]: points[index + 1].getPosition()\n        };\n        _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        points[index].setPosition(_points[index]);\n        points[index + 1].setPosition(_points[index + 1]);\n    }\n    draggingEvent(event, index) {\n        let points = this.props.link.getPoints();\n        // get moving difference. Index + 1 will work because links indexes has\n        // length = points.lenght - 1\n        let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n        let dy = Math.abs(points[index].getY() - points[index + 1].getY());\n        // moving with y direction\n        if (dx === 0) {\n            this.calculatePositions(points, event, index, 'x');\n        }\n        else if (dy === 0) {\n            this.calculatePositions(points, event, index, 'y');\n        }\n        this.props.link.setFirstAndLastPathsDirection();\n    }\n    render() {\n        //ensure id is present for all points on the path\n        let points = this.props.link.getPoints();\n        let paths = [];\n        // Get points based on link orientation\n        let pointLeft = points[0];\n        let pointRight = points[points.length - 1];\n        let hadToSwitch = false;\n        if (pointLeft.getX() > pointRight.getX()) {\n            pointLeft = points[points.length - 1];\n            pointRight = points[0];\n            hadToSwitch = true;\n        }\n        let dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n        // When new link add one middle point to get everywhere 90° angle\n        if (this.props.link.getTargetPort() === null && points.length === 2) {\n            [...Array(2)].forEach((item) => {\n                this.props.link.addPoint(new react_diagrams_core_1.PointModel({\n                    link: this.props.link,\n                    position: new geometry_1.Point(pointLeft.getX(), pointRight.getY())\n                }), 1);\n            });\n            this.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n        }\n        // When new link is moving and not connected to target port move with middle point\n        // TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n        //  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n        else if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n            points[1].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointLeft.getY() : pointRight.getY());\n            points[2].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointRight.getY() : pointLeft.getY());\n        }\n        // Render was called but link is not moved but user.\n        // Node is moved and in this case fix coordinates to get 90° angle.\n        // For loop just for first and last path\n        else if (!this.state.canDrag && points.length > 2) {\n            // Those points and its position only will be moved\n            for (let i = 1; i < points.length; i += points.length - 2) {\n                if (i - 1 === 0) {\n                    if (this.props.link.getFirstPathXdirection()) {\n                        points[i].setPosition(points[i].getX(), points[i - 1].getY());\n                    }\n                    else {\n                        points[i].setPosition(points[i - 1].getX(), points[i].getY());\n                    }\n                }\n                else {\n                    if (this.props.link.getLastPathXdirection()) {\n                        points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n                    }\n                    else {\n                        points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n                    }\n                }\n            }\n        }\n        // If there is existing link which has two points add one\n        // NOTE: It doesn't matter if check is for dy or dx\n        if (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n            this.props.link.addPoint(new react_diagrams_core_1.PointModel({\n                link: this.props.link,\n                position: new geometry_1.Point(pointLeft.getX(), pointRight.getY())\n            }));\n        }\n        for (let j = 0; j < points.length - 1; j++) {\n            paths.push(this.generateLink(react_diagrams_core_1.LinkWidget.generateLinePath(points[j], points[j + 1]), {\n                'data-linkid': this.props.link.getID(),\n                'data-point': j,\n                onMouseDown: (event) => {\n                    if (event.button === 0) {\n                        this.setState({ canDrag: true });\n                        this.dragging_index = j;\n                        // Register mouse move event to track mouse position\n                        // On mouse up these events are unregistered check \"this.handleUp\"\n                        window.addEventListener('mousemove', this.handleMove);\n                        window.addEventListener('mouseup', this.handleUp);\n                    }\n                },\n                onMouseEnter: (event) => {\n                    this.setState({ selected: true });\n                    this.props.link.lastHoverIndexOfPath = j;\n                }\n            }, j));\n        }\n        this.refPaths = [];\n        return React.createElement(\"g\", { \"data-default-link-test\": this.props.link.getOptions().testName }, paths);\n    }\n}\nexports.RightAngleLinkWidget = RightAngleLinkWidget;\nRightAngleLinkWidget.defaultProps = {\n    color: 'red',\n    width: 3,\n    link: null,\n    smooth: false,\n    diagramEngine: null,\n    factory: null\n};\n//# sourceMappingURL=RightAngleLinkWidget.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\nvar sq = function sq(x) {\n  return x * x;\n};\n\nvar distPointToPoint = function distPointToPoint(_ref, _ref3) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var ax = _ref2[0];\n  var ay = _ref2[1];\n\n  var _ref32 = _slicedToArray(_ref3, 2);\n\n  var bx = _ref32[0];\n  var by = _ref32[1];\n  return Math.sqrt(sq(ax - bx) + sq(ay - by));\n};\n\nvar distPointToParabol = function distPointToParabol(a, f) {\n  var p = distPointToPoint(a, f);\n\n  return p == 0 ? Infinity : sq(p) / (2 * Math.abs(a[1] - f[1]));\n};\n\nvar circumCenter = function circumCenter(a, b, c) {\n  var d = (a[0] - c[0]) * (b[1] - c[1]) - (b[0] - c[0]) * (a[1] - c[1]);\n\n  if (d == 0) return [Infinity, Infinity];\n\n  var xc = (((a[0] - c[0]) * (a[0] + c[0]) + (a[1] - c[1]) * (a[1] + c[1])) / 2 * (b[1] - c[1]) - ((b[0] - c[0]) * (b[0] + c[0]) + (b[1] - c[1]) * (b[1] + c[1])) / 2 * (a[1] - c[1])) / d;\n  var yc = (((b[0] - c[0]) * (b[0] + c[0]) + (b[1] - c[1]) * (b[1] + c[1])) / 2 * (a[0] - c[0]) - ((a[0] - c[0]) * (a[0] + c[0]) + (a[1] - c[1]) * (a[1] + c[1])) / 2 * (b[0] - c[0])) / d;\n  return [xc, yc];\n};\n\nvar parabolsCrossX = function parabolsCrossX(fa, fb, q) {\n  if (fa[1] === fb[1]) return [(fa[0] + fb[0]) / 2, (fa[0] + fb[0]) / 2];\n\n  var s1 = (fa[1] * fb[0] - fa[0] * fb[1] + fa[0] * q - fb[0] * q + Math.sqrt((fa[0] * fa[0] + fa[1] * fa[1] - 2 * fa[0] * fb[0] + fb[0] * fb[0] - 2 * fa[1] * fb[1] + fb[1] * fb[1]) * (fa[1] * fb[1] - fa[1] * q - fb[1] * q + q * q))) / (fa[1] - fb[1]);\n  var s2 = (fa[1] * fb[0] - fa[0] * fb[1] + fa[0] * q - fb[0] * q - Math.sqrt((fa[0] * fa[0] + fa[1] * fa[1] - 2 * fa[0] * fb[0] + fb[0] * fb[0] - 2 * fa[1] * fb[1] + fb[1] * fb[1]) * (fa[1] * fb[1] - fa[1] * q - fb[1] * q + q * q))) / (fa[1] - fb[1]);\n\n  return s1 < s2 ? [s1, s2] : [s2, s1];\n};\n\nvar doHalflinesCross = function doHalflinesCross(sa, sb) {\n  var approx = arguments.length <= 2 || arguments[2] === undefined ? 1e-10 : arguments[2];\n  //sa, sb are Segment instance\n  var dx = sb.ps[0] - sa.ps[0];\n  var dy = sb.ps[1] - sa.ps[1];\n\n  if (sa.m == Infinity) return sa.hp * (sb.m * dx - dy) <= approx && sb.vec[0] * dx <= approx;\n  if (sb.m == Infinity) return sb.hp * (sa.m * dx - dy) >= -approx && sa.vec[0] * dx >= -approx;\n\n  var det = sb.vec[0] * sa.vec[1] - sb.vec[1] * sa.vec[0];\n\n  if (det === 0) return false;\n\n  var u = (dy * sb.vec[0] - dx * sb.vec[1]) / det;\n  var v = (dy * sa.vec[0] - dx * sa.vec[1]) / det;\n\n  return u >= -approx && v >= approx || u >= approx && v >= -approx;\n};\n\nvar matrixTransform = function matrixTransform(points, matrix) {\n  return points.map(function (point) {\n    return {\n      x: point.x * matrix[0] + point.y * matrix[2] + matrix[4],\n      y: point.x * matrix[1] + point.y * matrix[3] + matrix[5]\n    };\n  });\n};\n\nvar transformEllipse = function transformEllipse(rx, ry, ax, m) {\n  var torad = Math.PI / 180;\n  var epsilon = 0.0000000001;\n\n  var c = Math.cos(ax * torad),\n      s = Math.sin(ax * torad);\n  var ma = [rx * (m[0] * c + m[2] * s), rx * (m[1] * c + m[3] * s), ry * (-m[0] * s + m[2] * c), ry * (-m[1] * s + m[3] * c)];\n\n  var J = ma[0] * ma[0] + ma[2] * ma[2],\n      K = ma[1] * ma[1] + ma[3] * ma[3];\n\n  var D = ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) * ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]));\n\n  var JK = (J + K) / 2;\n\n  if (D < epsilon * JK) {\n    return {\n      rx: Math.sqrt(JK),\n      ry: Math.sqrt(JK),\n      ax: 0,\n      isDegenerate: false\n    };\n  }\n\n  var L = ma[0] * ma[1] + ma[2] * ma[3];\n  D = Math.sqrt(D);\n\n  var l1 = JK + D / 2,\n      l2 = JK - D / 2;\n\n  var newAx = undefined,\n      newRx = undefined,\n      newRy = undefined;\n  newAx = Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon ? 90 : Math.atan(Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)) * 180 / Math.PI;\n\n  if (newAx >= 0) {\n    newRx = Math.sqrt(l1);\n    newRy = Math.sqrt(l2);\n  } else {\n    newAx += 90;\n    newRx = Math.sqrt(l2);\n    newRy = Math.sqrt(l1);\n  }\n\n  return {\n    rx: newRx,\n    ry: newRy,\n    ax: newAx,\n    isDegenerate: newRx < epsilon * newRy || newRy < epsilon * newRx\n  };\n};\n\nexports[\"default\"] = { distPointToPoint: distPointToPoint, distPointToParabol: distPointToParabol, circumCenter: circumCenter,\n  parabolsCrossX: parabolsCrossX, doHalflinesCross: doHalflinesCross, matrixTransform: matrixTransform, transformEllipse: transformEllipse };\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar _geom = require('./geom');\n\nvar Path = function Path(init) {\n  var _instructions = init || [];\n\n  var push = function push(arr, el) {\n    var copy = arr.slice(0, arr.length);\n    copy.push(el);\n    return copy;\n  };\n\n  var areEqualPoints = function areEqualPoints(_ref, _ref3) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var a1 = _ref2[0];\n    var b1 = _ref2[1];\n\n    var _ref32 = _slicedToArray(_ref3, 2);\n\n    var a2 = _ref32[0];\n    var b2 = _ref32[1];\n    return a1 === a2 && b1 === b2;\n  };\n\n  var trimZeros = function trimZeros(string, char) {\n    var l = string.length;\n    while (string.charAt(l - 1) === '0') {\n      l = l - 1;\n    }\n    if (string.charAt(l - 1) === '.') {\n      l = l - 1;\n    }\n    return string.substr(0, l);\n  };\n\n  var round = function round(number, digits) {\n    var str = number.toFixed(digits);\n    return trimZeros(str);\n  };\n\n  var printInstrunction = function printInstrunction(_ref4) {\n    var command = _ref4.command;\n    var params = _ref4.params;\n\n    var numbers = params.map(function (param) {\n      return round(param, 6);\n    });\n    return command + ' ' + numbers.join(' ');\n  };\n\n  var point = function point(_ref5, prev) {\n    var command = _ref5.command;\n    var params = _ref5.params;\n\n    switch (command) {\n      case 'M':\n        return [params[0], params[1]];\n      case 'L':\n        return [params[0], params[1]];\n      case 'H':\n        return [params[0], prev[1]];\n      case 'V':\n        return [prev[0], params[0]];\n      case 'Z':\n        return null;\n      case 'C':\n        return [params[4], params[5]];\n      case 'S':\n        return [params[2], params[3]];\n      case 'Q':\n        return [params[2], params[3]];\n      case 'T':\n        return [params[0], params[1]];\n      case 'A':\n        return [params[5], params[6]];\n    }\n  };\n\n  var transformParams = function transformParams(instruction, matrix, prev) {\n    var p = instruction.params;\n\n    var transformer = {\n      'V': function V(instruction, matrix, prev) {\n        var pts = [{ x: prev[0], y: p[0] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        if (newPts[0].x === (0, _geom.matrixTransform)([{ x: prev[0], y: prev[1] }], matrix)[0].x) {\n          return {\n            command: 'V',\n            params: [newPts[0].y]\n          };\n        } else {\n          return {\n            command: 'L',\n            params: [newPts[0].x, newPts[0].y]\n          };\n        }\n      },\n      'H': function H(instruction, matrix, prev) {\n        var pts = [{ x: p[0], y: prev[1] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        if (newPts[0].y === (0, _geom.matrixTransform)([{ x: prev[0], y: prev[1] }], matrix)[0].y) {\n          return {\n            command: 'H',\n            params: [newPts[0].x]\n          };\n        } else {\n          return {\n            command: 'L',\n            params: [newPts[0].x, newPts[0].y]\n          };\n        }\n      },\n      'A': function A(instruction, matrix, prev) {\n        // transform rx, ry, and x-axis rotation\n        var r = (0, _geom.transformEllipse)(p[0], p[1], p[2], matrix);\n\n        var sweepFlag = p[4];\n        if (matrix[0] * matrix[3] - matrix[1] * matrix[2] < 0) {\n          sweepFlag = sweepFlag ? '0' : '1';\n        }\n\n        // transform endpoint\n        var pts = [{ x: p[5], y: p[6] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n\n        if (r.isDegenerate) {\n          return {\n            command: 'L',\n            params: [newPts[0].x, newPts[0].y]\n          };\n        } else {\n          return {\n            command: 'A',\n            params: [r.rx, r.ry, r.ax, p[3], sweepFlag, newPts[0].x, newPts[0].y]\n          };\n        }\n      },\n      'C': function C(instruction, matrix, prev) {\n        var pts = [{ x: p[0], y: p[1] }, { x: p[2], y: p[3] }, { x: p[4], y: p[5] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        return {\n          command: 'C',\n          params: [newPts[0].x, newPts[0].y, newPts[1].x, newPts[1].y, newPts[2].x, newPts[2].y]\n        };\n      },\n      'Z': function Z(instruction, matrix, prev) {\n        return {\n          command: 'Z',\n          params: []\n        };\n      },\n      'default': function _default(instruction, matrix, prev) {\n        var pts = [{ x: p[0], y: p[1] }];\n        var newPts = (0, _geom.matrixTransform)(pts, matrix);\n        var newParams = instruction.params.slice(0, instruction.params.length);\n        newParams.splice(0, 2, newPts[0].x, newPts[0].y);\n        return {\n          command: instruction.command,\n          params: newParams\n        };\n      }\n    };\n\n    if (transformer[instruction.command]) {\n      return transformer[instruction.command](instruction, matrix, prev);\n    } else {\n      return transformer['default'](instruction, matrix, prev);\n    }\n  };\n\n  var verbosify = function verbosify(keys, f) {\n    return function (a) {\n      var args = typeof a === 'object' ? keys.map(function (k) {\n        return a[k];\n      }) : arguments;\n      return f.apply(null, args);\n    };\n  };\n\n  var plus = function plus(instruction) {\n    return Path(push(_instructions, instruction));\n  };\n\n  return {\n    moveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'M',\n        params: [x, y]\n      });\n    }),\n    lineto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'L',\n        params: [x, y]\n      });\n    }),\n    hlineto: verbosify(['x'], function (x) {\n      return plus({\n        command: 'H',\n        params: [x]\n      });\n    }),\n    vlineto: verbosify(['y'], function (y) {\n      return plus({\n        command: 'V',\n        params: [y]\n      });\n    }),\n    closepath: function closepath() {\n      return plus({\n        command: 'Z',\n        params: []\n      });\n    },\n    curveto: verbosify(['x1', 'y1', 'x2', 'y2', 'x', 'y'], function (x1, y1, x2, y2, x, y) {\n      return plus({\n        command: 'C',\n        params: [x1, y1, x2, y2, x, y]\n      });\n    }),\n    smoothcurveto: verbosify(['x2', 'y2', 'x', 'y'], function (x2, y2, x, y) {\n      return plus({\n        command: 'S',\n        params: [x2, y2, x, y]\n      });\n    }),\n    qcurveto: verbosify(['x1', 'y1', 'x', 'y'], function (x1, y1, x, y) {\n      return plus({\n        command: 'Q',\n        params: [x1, y1, x, y]\n      });\n    }),\n    smoothqcurveto: verbosify(['x', 'y'], function (x, y) {\n      return plus({\n        command: 'T',\n        params: [x, y]\n      });\n    }),\n    arc: verbosify(['rx', 'ry', 'xrot', 'largeArcFlag', 'sweepFlag', 'x', 'y'], function (rx, ry, xrot, largeArcFlag, sweepFlag, x, y) {\n      return plus({\n        command: 'A',\n        params: [rx, ry, xrot, largeArcFlag, sweepFlag, x, y]\n      });\n    }),\n    translate: verbosify(['dx', 'dy'], function () {\n      var dx = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n      var dy = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      if (dx !== 0 || dy !== 0) {\n        var _ret = (function () {\n          var prev = [0, 0];\n          var matrix = [1, 0, 0, 1, dx, dy];\n          var newInstructions = _instructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret === 'object') return _ret.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    rotate: verbosify(['angle', 'rx', 'ry'], function (angle) {\n      var rx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var ry = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n      if (angle !== 0) {\n        var _ret2 = (function () {\n          var prev = undefined;\n          var matrix = undefined;\n          var newInstructions = _instructions;\n\n          if (rx !== 0 && ry !== 0) {\n            prev = [0, 0];\n            matrix = [1, 0, 0, 1, -rx, -ry];\n            newInstructions = newInstructions.map(function (instruction) {\n              var p = transformParams(instruction, matrix, prev);\n              prev = point(instruction, prev);\n              return p;\n            });\n          }\n\n          var rad = angle * Math.PI / 180;\n          var cos = Math.cos(rad);\n          var sin = Math.sin(rad);\n\n          prev = [0, 0];\n          matrix = [cos, sin, -sin, cos, 0, 0];\n          newInstructions = newInstructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n\n          if (rx !== 0 && ry !== 0) {\n            prev = [0, 0];\n            matrix = [1, 0, 0, 1, rx, ry];\n            newInstructions = newInstructions.map(function (instruction) {\n              var p = transformParams(instruction, matrix, prev);\n              prev = point(instruction, prev);\n              return p;\n            });\n          }\n\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret2 === 'object') return _ret2.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    scale: verbosify(['sx', 'sy'], function () {\n      var sx = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n      var sy = arguments.length <= 1 || arguments[1] === undefined ? sx : arguments[1];\n      return (function () {\n        if (sx !== 1 || sy !== 1) {\n          var _ret3 = (function () {\n            var prev = [0, 0];\n            var matrix = [sx, 0, 0, sy, 0, 0];\n            var newInstructions = _instructions.map(function (instruction) {\n              var p = transformParams(instruction, matrix, prev);\n              prev = point(instruction, prev);\n              return p;\n            });\n            return {\n              v: Path(newInstructions)\n            };\n          })();\n\n          if (typeof _ret3 === 'object') return _ret3.v;\n        } else {\n          return Path(_instructions);\n        }\n      })();\n    }),\n    shearX: verbosify(['angle'], function () {\n      var angle = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n      if (angle !== 0) {\n        var _ret4 = (function () {\n          var prev = [0, 0];\n          var matrix = [1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0];\n          var newInstructions = _instructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret4 === 'object') return _ret4.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    shearY: verbosify(['angle'], function () {\n      var angle = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n      if (angle !== 0) {\n        var _ret5 = (function () {\n          var prev = [0, 0];\n          var matrix = [1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0];\n          var newInstructions = _instructions.map(function (instruction) {\n            var p = transformParams(instruction, matrix, prev);\n            prev = point(instruction, prev);\n            return p;\n          });\n          return {\n            v: Path(newInstructions)\n          };\n        })();\n\n        if (typeof _ret5 === 'object') return _ret5.v;\n      } else {\n        return Path(_instructions);\n      }\n    }),\n    print: function print() {\n      return _instructions.map(printInstrunction).join(' ');\n    },\n    toString: function toString() {\n      return undefined.print();\n    },\n    points: function points() {\n      var ps = [];\n      var prev = [0, 0];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _instructions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var instruction = _step.value;\n\n          var p = point(instruction, prev);\n          prev = p;\n          if (p) {\n            ps.push(p);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return ps;\n    },\n    instructions: function instructions() {\n      return _instructions.slice(0, _instructions.length);\n    },\n    connect: function connect(path) {\n      var ps = this.points();\n      var last = ps[ps.length - 1];\n      var first = path.points()[0];\n      var newInstructions = undefined;\n      if (_instructions[_instructions.length - 1].command !== 'Z') {\n        newInstructions = path.instructions().slice(1);\n        if (!areEqualPoints(last, first)) {\n          newInstructions.unshift({\n            command: \"L\",\n            params: first\n          });\n        }\n      } else {\n        newInstructions = path.instructions();\n      }\n      return Path(this.instructions().concat(newInstructions));\n    }\n  };\n};\n\nexports['default'] = function () {\n  return Path();\n};\n\nmodule.exports = exports['default'];"],"names":[],"sourceRoot":""}